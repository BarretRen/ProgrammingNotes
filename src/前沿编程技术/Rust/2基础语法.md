
# 1 关键字
只列出C++中没有的，相同含义的不列出：

- as - **强制类型转换**， 消除特定包含项的 trait 的歧义， 或者对 use 和 extern crate 语句中的项重命名
- crate - 链接（ link） 一个外部 crate 或一个代表宏定义的 crate 的宏变量
- dyn - 动态分发 trait 对象
- fn - **定义一个函数或 函数指针类型** (function pointer type)
- for - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期
- impl - 实现自有或 trait 功能
- in - for 循环语法的一部分
- let - 绑定一个变量**，默认不可修改，可以多次使用并改变类型**
- loop - 无条件循环
- match - 模式匹配
- mod - 定义一个模块
- move - 使闭包获取其所捕获项的所有权
- **mut **- **表示引用、 裸指针或模式可以修改，但不能改变类型**
- pub - 表示结构体字段、 impl 块或模块的公有可见性
- ref - 通过引用绑定
- **Self **- 实现 trait 的类型的类型别名
- **self **- 表示方法本身或当前模块
- static - 表示全局变量或在整个程序执行期间保持其生命周期
- super - 表示当前模块的父模块
- trait - 定义一个 trait
- type - 定义一个类型别名或关联类型
- unsafe - 表示不安全的代码、 函数、 trait 或实现
- use - 引入外部空间的符号
- where - 表示一个约束类型的从句
- **常量**：`const MAX_POINTS: u32 = 100_000; `




# 2 数据类型
在 Rust 中， 每一个值都属于某一个 数据类型（ data type） ， 这告诉 Rust 它被指定为何种数据， 以便明确数据处理方式。 我们将看到两类数据类型子集： 标量（ scalar） 和复合（ compound）。​

Rust 有四种基本的标量类型： **整型、 浮点型、 布尔类型（bool）和字符类型（char）**。

## 2.1 整型
| **长度 ** | **有符号 ** | **无符号** |
| --- | --- | --- |
| 8-bit  | i8  | u8 |
| 16-bit  | i16  | u16 |
| 32-bit  | i32（默认类型） | u32 |
| 64-bit  | i64  | u64 |
| 128-bit  | i128  | u128 |
| arch（依赖系统架构，64或32） | isize  | usize |


## 2.2 浮点数
Rust的浮点数类型是 **f32 和 f64 **， 分别占 32 位和 64 位。 **默认类型是 f64** ， 因为在现代 CPU中， 它与 f32 速度几乎一样， 不过精度更高。


## 2.3 复合类型

### 元组
元组是一个将多个其他类型的值组合进一个复合类型的主要方式。** 元组长度固定：** 一旦声明， 其长度不会增大或缩小。
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);  //定义元组
//元组解构
let (x, y, z) = tup; //使用新变量保存解构后值
let first = tup.0; //指定获取元组的哪个值
```

### 数组
Rust 中， 数组中的值位于中括号内的逗号分隔的列表中：
```rust
let a = [1, 2, 3, 4, 5];
//或
let a: [i32; 5] = [1, 2, 3, 4, 5];//显示指定类型和个数
```

## 2.4 String类型
String类型不是基本类型，是标准库提供的扩展类型，基本用法如下：
```rust
let mut s = String::from("hello");  //初始化string
s.push_str(", world!"); // push_str() 在字符串后追加字面值
println!("{}", s); // 将打印 `hello, world!
let chars = s.as_bytes(); //将字符串转为字符数组
```

## 2.5 struct结构体
结构体定义和C++基本一致，不同的是成员末尾使用逗号：
```rust
struct Rectangle {
    width: u32,
    height: u32,
}
```
可以使用`impl`为结构体添加成员函数（C++是可以直接写在结构体中，rust没有类的概念，所以需要写在结构体外）：
```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
//调用函数：
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1.area());
}
```
而对于下面这种成员函数，参数中没有`self`，意味着这属于类不属于对象（C++的概念），所以调用时需要使用`结构体名::函数名`：
```rust
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let sq = Rectangle::square(3);
}
```

# 3 函数
Rust 代码中的函数和变量名使用 snake case 规范风格。 在 snake case 中， 所有字母都是小写并使用下划线分隔单词。Rust 中的函数定义**以 fn 开始并在函数名后跟一对圆括号**。 大括号告诉编译器哪里是函数体的开始和结尾。Rust 不关心函数定义于何处， 只要定义了就行。

## 3.1 函数参数
```rust
fn another_function(x: i32, y: i32) {//参数和类型
	println!("The value of x is: {}", x);
	println!("The value of y is: {}", y);
}
```

## 3.2 返回值
函数可以向调用它的代码返回值。 我们并不对返回值命名， 但要**在箭头（ -> ） 后声明它的类型**。使用 return 关键字指定返回值。
```rust
fn another_function(x: i32) -> i32 {//返回值类型
    println!("The value of x is: {}", x);
    return 100;
}
```

# 4 控制流

## 4.1 if语句
所有的 if 表达式都以 if 关键字开头， 其后跟一个条件（不需要括号）：
```rust
fn main() {
    let number = 3;
	//if语句，表达式结果必须为bool类型
	if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
**注意**：

- **Rust 并不会尝试自动地将非布尔值转换为布尔值。 必须总是显式地使用布尔值作为 if的条件。** 
- **enum类型不能直接在if里判断（因为enum类没有实现==运算符），需要借助**`**match**`**或**`**if let**`**进行判断**

## 4.2 循环
Rust 有三种循环： **loop 、 while 和 for** 。

### loop
loop可以执行一个循环，但是没有终止条件，需要在内部使用**break**返回，同时**break可以携带返回值，将loop的最终结果赋给一个变量**。
```rust
let mut counter = 0;
    let result = loop {//loop返回值赋给了result变量
        counter += 1;
        if counter == 10 {
            break counter * 2; //注意，break可以携带返回值
        }
    };
```

### while
```rust
fn main() {
    let mut number = 3;
    while number != 0 {
        println!("{}!", number);
        number = number - 1;
    }
}
```

### for
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter() {                 //直接生成一个index的迭代器遍历，不直接使用index，防止越界
        println!("the value is: {}", element);
    }
    println!();
    for element in a.iter().rev() {          //rev用来反转index序列，从后往前输出
        println!("the value is: {}", element);
    }
    println!();
	for i in 1..3 {                          //直接用index，不用迭代器
        println!("the value is: {}", a[i]);
    }
}
```
