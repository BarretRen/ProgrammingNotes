> Docker的基本命令和Git很相似，在记忆时可以联想Git相关命令的含义。


# 1 获取image
配置好了仓库之后，我们就可以从仓库获取镜像了。从Docker镜像仓库获取镜像的命令是`docker pull`，其命令格式为：
```bash
docker pull [选项] [<仓库域名/IP>[:端口号]/]仓库名[:标签]
```

- 标签：可以指定镜像的版本，比如`ubuntu:20.04`，不指定版本则默认版本

# 2 运行镜像
```bash
docker run -it --rm ubuntu:20.04 bash
```

- -it ： 这是两个参数， 一个是 -i ： 交互式操作， 一个是 -t 终端
- --rm: 退出时删除容器。也可以事后用`docker rm`删除

# 3 列出已下载镜像
```bash
barret@blinux:~$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
ubuntu       20.04     f643c72bc252   5 weeks ago   72.9MB
```

# 4 删除镜像
```bash
docker image rm [选项] <镜像1> [<镜像2> ...]
```

- <镜像>：可以是**镜像短ID 、镜像长ID 、镜像名或者镜像摘要**

# 5 保存容器修改为镜像
当我们运行一个容器的时候（ 如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。`docker commit`命令，可以将容器的存储层保存下来成为镜像。在原有镜像的基础上， 再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候， 就会拥有原有容器最后的文件变化。
```bash
docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]
```

commit的缺点：

- 使用 docker commit 意味着所有对镜像的操作都是**黑箱操作**，除了制作镜像的人知道执行过什么命令、怎么生成的镜像， 别人根本无从得知
- 每一次修改都会让镜像更加臃肿一次， **所删除的上一层的东西并不会丢失**， 会一直如影随形的跟着这个镜像， 即使根本无法访问到。 这会让镜像更加臃肿
